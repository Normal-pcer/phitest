<!DOCTYPE html>
<html lang="zh-cn">
	<head>
		<meta charset="UTF-8" />
		<title>Document</title>
		<style>
			.judgel {
				position: absolute;
				top: 600px;
				border-top: 3px solid #dfe4ea;
				height: 20px;
				width: 100%;
			}
			.tap {
				background-color: #1e90ff;
				color: #dfe4ea;
			}
			#showCombo {
				color: #dfe4ea;
				text-align: center;
			}
			#comboNum {
				font-size: 1.5em;
			}
			#showScore {
				color: #dfe4ea;
				text-align: right;
				font-size: 1.5em;
			}
			.effect {
				width: 80px;
				height: 80px;
				position: absolute;
			}
			.perfect {
				border: #fdcb6e 3px solid;
			}
			.good {
				border: #1e90ff solid 3px;
			}
			.bad {
				border: #dfe4ea solid 3px;
			}
		</style>
	</head>
	<body style="background-color: #2f3542">
		<!-- <img src="source/tap.jpg" alt="[Tap Note]" class="note tap"> -->
		<!-- 现在使用CSS绘制音符、判定线等 -->
		<div id="notes"></div>
		<div id="judgelines"></div>
		<div id="showCombo">
			<span id="comboNum"></span><br />
			<span>COMBO</span>
		</div>
		<div id="showScore">
			<span id="scoreNum"></span>
		</div>
		<div id="effects"></div>

		<script>
			const MAX_HEIGHT = 800;
			const WIDTH = 1000;
			const PERFECT = 40; // {PERFECT}px以内为Perfect判定
			const PSCORE = 5000; // Percect判定的加分
			const GOOD = 80;
			const GSCORE = 0.65 * PSCORE;
			const BAD = 100;
			const EFFECT_LAST = 5; // 特效持续{}刻
			let countOfNotes = 0;
			let countOfLines = 0;
			let combo = 0;
			let tick = 1;
			let score = 0;
			const keyOrder = 'QWERT';
			const keyCodeOrder = [81, 87, 69, 82, 84];

			const pad = (num, cover) =>
				'0'.repeat(cover).concat(num).slice(-cover);
			let effects_to_remove = new Array();

			function createEffect(type = 'perfect', x, y) {
				let effect = document.createElement('div');
				effect.className = 'effect ' + type;
				effect.style =
					'top: ' +
					(y - 40).toString() +
					'px; left: ' +
					(x - 40).toString() +
					'px;';
				document.getElementById('effects').appendChild(effect);
				effects_to_remove.push([effect, tick + EFFECT_LAST]);
			}
			function removeEffect() {
				// 应自动执行
				for (let i = 0; i < effects_to_remove.length; i++) {
					let element = effects_to_remove[i];
					if (tick >= element[1]) element[0].remove();
				}
			}
			function createTapNote(xPos = 0) {
				let tap = document.createElement('div');
				tap.className =
					'note tap ' +
					keyOrder[Math.floor(xPos / (WIDTH / 5))] +
					'judge';
				tap.id = 'note' + countOfNotes;
				tap.style =
					'width: 100px; height: 25px; position: absolute; top: 0px; left: ' +
					xPos +
					'px;';
				document.getElementById('notes').appendChild(tap);
				tap.innerHTML = (
					keyOrder[Math.floor(xPos / (WIDTH / 5))] + ' '
				).repeat(4);
				countOfNotes++;
			}

			function createJudgeLine(yPos = 0) {
				let line = document.createElement('div');
				line.className = 'judgel';
				line.id = 'jl' + countOfLines;
				line.style = 'top: ' + yPos + 'px';
				document.getElementById('judgelines').appendChild(line);
				countOfLines++;
			}

			function notesFall() {
				let notes = document.getElementsByClassName('note');
				for (let i = 0; i < notes.length; i++) {
					let note = notes[i];
					note.style.top = parseInt(note.style.top) + 20 + 'px';
					if (parseInt(note.style.top) >= MAX_HEIGHT) {
						note.remove();
						combo = 0;
					}
				}
			}

			function sleep(time) {
				return new Promise((resolve) => setTimeout(resolve, time));
			}

			function randbet(l = 0, r = 1) {
				return Math.random() * (r - l + 1) + l;
			}

			function onclick() {
				let mousePos = [Number(event.pageX), Number(event.pageY)];

				// 默认在最新生成的判定线上进行判定
				let lines = document.getElementsByClassName('judgel');
				if (lines.length == 0) return; // 没有判定线还判定个寂寞
				let maxId = 0;
				let maxElement = lines[0];
				for (let i = 0; i < lines.length; i++) {
					let element = lines[i];
					if (parseInt(element.id.substr(2)) > maxId) {
						maxId = parseInt(element.id.substr(2));
						maxElement = element;
					}
				}
				let lastLine = maxElement;

				let yPos = parseInt(lastLine.style.top);
				let xPos = mousePos[0];
				
				judgeNote(xPos, yPos)
			}
			function judgeNote (xPos, yPos) {
				// 判定距离该位置最近的Note
				let notes = document.getElementsByClassName('note');
				if (notes.length == 0) return; // 没有Note还判定个寂寞
				let minDistance = 1048576;
				let minNote = notes[0];
				let flag = false;
				for (let i = 0; i < notes.length; i++) {
					let element = notes[i];
					let eleX = parseInt(element.style.left)+50;
					let eleY = parseInt(element.style.top)+12.5;
					let distance =
						Math.pow(eleX - xPos, 2) + Math.pow(eleY - yPos, 2);

					if (Math.abs(eleX - xPos) >= 0.1 * WIDTH) continue;
					else if (i == 0) {
						minDistance = distance;
						minNote = element;
					} else if (distance < minDistance) {
						minDistance = distance;
						minNote = element;
					}
					flag = true;
				}
				if (flag) {
					let distanceY = Math.abs(
						parseInt(minNote.style.top) - yPos
					);
					if (distanceY <= PERFECT) {
						createEffect(
							'perfect',
							parseInt(minNote.style.left) + 50,
							parseInt(yPos)
						);
						minNote.remove();
						combo++;
						score += PSCORE;
					} else if (distanceY <= GOOD) {
						createEffect(
							'good',
							parseInt(minNote.style.left) + 50,
							parseInt(yPos)
						);
						minNote.remove();
						combo++;
						score += GSCORE;
					} else if (distanceY <= BAD) {
						createEffect(
							'bad',
							parseInt(minNote.style.left) + 50,
							parseInt(yPos)
						);
						minNote.remove();
						combo = 0;
					}
				}
			}
			function keyup() {
				let e = window.event
				let kc = e.keyCode;

				// 默认在最新生成的判定线上进行判定
				let lines = document.getElementsByClassName('judgel');
				if (lines.length == 0) return; // 没有判定线还判定个寂寞
				let maxId = 0;
				let maxElement = lines[0];
				for (let i = 0; i < lines.length; i++) {
					let element = lines[i];
					if (parseInt(element.id.substr(2)) > maxId) {
						maxId = parseInt(element.id.substr(2));
						maxElement = element;
					}
				}
				let lastLine = maxElement;

				let yPos = parseInt(lastLine.style.top);
				let xPos = (WIDTH/5) * keyCodeOrder.indexOf(kc) + (WIDTH/10)

				judgeNote(xPos, yPos)
			}

			window.onload = async function () {
				createTapNote();
				createJudgeLine(600);
				addEventListener('click', onclick, false);
				addEventListener('keyup', keyup, true)
				while (true) {
					document.getElementById('comboNum').innerHTML =
						combo.toString();
					document.getElementById('scoreNum').innerHTML = (score<1000000?(pad(
						score,
						7
					)) : "我说你φ了你信不");
					await sleep(40);
					notesFall();
					removeEffect();
					if (tick % 10 == 0) {
						createTapNote(randbet(0, WIDTH - 1));
					}
					tick++;
				}
			};
		</script>
	</body>
</html>
